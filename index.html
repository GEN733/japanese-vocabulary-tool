<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ—¥è¯­å•è¯èƒŒè¯µ - å¢å¼ºç‰ˆ (å«GitHubåŒæ­¥)</title>
    <style>
        body { font-family: Arial; padding: 20px; background: #f0f0f0; }
        .tab { display: flex; margin-bottom: 20px; flex-wrap: wrap; }
        .tab button { flex: 1; min-width: 80px; padding: 10px; border: none; background: #ddd; font-size: 14px; }
        .tab button.active { background: #4a6fa5; color: white; }
        .page { display: none; background: white; padding: 20px; border-radius: 10px; }
        .page.active { display: block; }
        input { width: 100%; padding: 10px; margin: 10px 0; font-size: 16px; }
        button { padding: 10px 20px; margin: 5px; background: #4a6fa5; color: white; border: none; border-radius: 5px; cursor: pointer; }
        .word { font-size: 24px; font-weight: bold; margin: 20px; text-align: center; min-height: 40px; }
        .word.correct { color: green; }
        .word.wrong { color: red; }
        .result { padding: 10px; margin: 10px 0; text-align: center; font-size: 18px; font-weight: bold; }
        .result.correct { color: green; background: #e8f5e8; border-radius: 8px; }
        .result.wrong { color: red; background: #ffebee; border-radius: 8px; }
        textarea { width: 100%; height: 150px; padding: 10px; }
        .progress-bar { height: 20px; background: #e0e0e0; border-radius: 10px; margin: 10px 0; overflow: hidden; }
        .progress-fill { height: 100%; background: #4a6fa5; transition: width 0.3s; }
        .settings { background: #e3f2fd; padding: 15px; border-radius: 8px; margin: 15px 0; }
        select { padding: 8px; font-size: 16px; margin: 0 10px; }
        .wrong-count { display: inline-block; background: #ff4444; color: white; padding: 2px 8px; border-radius: 10px; font-size: 12px; margin-left: 10px; }
        .stats-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin: 15px 0; }
        .stat-item { background: #f5f5f5; padding: 10px; border-radius: 8px; text-align: center; }
        .stat-value { font-size: 24px; font-weight: bold; color: #4a6fa5; }
        
        /* ========== ç¬¬ä¸€é˜¶æ®µä¼˜åŒ–æ–°å¢æ ·å¼ ========== */
        #result {
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .bottom-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        .bottom-actions button {
            flex: 1;
            padding: 12px 5px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            color: white;
        }
        .btn-start { background: #4CAF50; }
        .btn-reset { background: #f44336; }
        .btn-mark { background: #ff9800; }
        
        .primary-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        .primary-btn {
            flex: 1;
            padding: 15px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            color: white;
        }
        .primary-btn.check {
            background: #4CAF50;
        }
        .primary-btn.next {
            background: #2196F3;
        }
        
        .current-answer {
            margin-top: 10px;
            font-size: 18px;
            color: #666;
            text-align: center;
            min-height: 1.5em;
        }
        #currentAnswerText {
            color: #222;
            font-weight: bold;
        }

        /* ========== è¯åº“ç®¡ç†æ–°å¢æ ·å¼ ========== */
        .deck-manager {
            margin-top: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            background: #f9f9f9;
        }
        
        .deck-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }
        
        .deck-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        
        .deck-card {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            position: relative;
        }
        
        .deck-card h4 {
            margin-top: 0;
            color: #4a6fa5;
        }
        
        .deck-stats {
            font-size: 12px;
            color: #666;
            margin: 5px 0;
        }
        
        .deck-actions {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }
        
        .deck-actions button {
            padding: 5px 10px;
            font-size: 12px;
            flex: 1;
        }
        
        .btn-delete {
            background: #f44336;
        }
        
        .btn-edit {
            background: #ff9800;
        }
        
        .btn-view {
            background: #4CAF50;
        }
        
        .import-controls {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        /* ========== å•è¯ç¼–è¾‘æ ·å¼ ========== */
        .edit-form {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            z-index: 1000;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .edit-form h3 {
            margin-top: 0;
            color: #4a6fa5;
        }
        
        .edit-form .form-group {
            margin-bottom: 15px;
        }
        
        .edit-form label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 999;
        }
        
        .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #ddd;
            color: #333;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 18px;
            cursor: pointer;
        }
        
        /* ========== ä¸Šä¼ è®°å½•æ ·å¼ ========== */
        .upload-history {
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
        }
        
        .upload-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #eee;
        }
        
        .upload-item:last-child {
            border-bottom: none;
        }
        
        /* æ–°å¢é”™é¢˜ç§»é™¤æŒ‰é’®æ ·å¼ */
        .remove-wrong-btn {
            margin-top: 10px;
            padding: 8px 15px;
            background: #ff9800;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        
        /* å“åº”å¼è°ƒæ•´ */
        @media (max-width: 768px) {
            .deck-list {
                grid-template-columns: 1fr;
            }
            
            .primary-actions, .bottom-actions {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <h1>ğŸ“š æ—¥è¯­å•è¯èƒŒè¯µ - å¢å¼ºç‰ˆ (å«GitHubåŒæ­¥)</h1>
    
    <div class="tab">
        <button class="active" onclick="showPage('practice')">ç»ƒä¹ </button>
        <button onclick="showPage('wrong')">é”™é¢˜</button>
        <button onclick="showPage('manage')">ç®¡ç†</button>
        <button onclick="showPage('sync')">åŒæ­¥</button>
        <button onclick="showPage('decks')">è¯åº“</button>
    </div>
    
    <!-- ç»ƒä¹ é¡µé¢ -->
    <div id="practice" class="page active">
        <h2>ç»ƒä¹ æ¨¡å¼</h2>
        
        <div class="settings">
            <h3>é€‰æ‹©ç»ƒä¹ æ¨¡å¼</h3>
            <div class="mode-selector">
                <label>ç»ƒä¹ æ¨¡å¼ï¼š</label>
                <select id="practiceMode" onchange="onPracticeModeChange()">
                    <option value="unit" selected>å•å…ƒç»ƒä¹ </option>
                    <option value="review">æ±‡æ€»ç»ƒä¹ </option>
                    <option value="wrong">é”™é¢˜ç»ƒä¹ </option>
                    <option value="all">å…¨éƒ¨å•è¯</option>
                </select>
            </div>

            <div id="deckSelectorContainer" class="deck-selector">
                <div>
                    <label>é€‰æ‹©ä¹¦æœ¬ï¼š</label>
                    <select id="bookSelect" onchange="onBookSelectChange()"></select>
                </div>
                <div id="unitSelectorWrapper" style="margin-top: 10px;">
                    <label>é€‰æ‹©å•å…ƒï¼š</label>
                    <select id="unitSelect"></select>
                </div>
            </div>

            <h3>ç»ƒä¹ è®¾ç½®</h3>
            <div>
                <label>æ¯æ¬¡ç»ƒä¹ å•è¯æ•°ï¼š</label>
                <select id="practiceCount" onchange="saveSettings()">
                    <option value="10">10ä¸ª</option>
                    <option value="20">20ä¸ª</option>
                    <option value="30" selected>30ä¸ª</option>
                    <option value="50">50ä¸ª</option>
                    <option value="100">100ä¸ª</option>
                    <option value="0">å…¨éƒ¨</option>
                </select>
            </div>
        </div>
        
        <div class="stats-grid">
            <div class="stat-item">
                <div class="stat-value" id="currentProgress">0</div>
                <div>å½“å‰è¿›åº¦</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="totalPractice">0</div>
                <div>æœ¬æ¬¡æ€»æ•°</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="correctRate">0%</div>
                <div>æ­£ç¡®ç‡</div>
            </div>
        </div>
        
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill" style="width: 0%"></div>
        </div>
        
        <div class="word" id="question">ç‚¹å‡»å¼€å§‹æŒ‰é’®</div>
        
        <div id="result" class="result"></div>
        
        <!-- æ–°å¢é”™é¢˜ç§»é™¤é€‰é¡¹åŒºåŸŸ -->
        <div id="wrongRemovalOption" style="display: none; text-align: center; margin-top: 10px;">
            <button id="removeFromWrongBtn" class="remove-wrong-btn" onclick="removeCurrentWordFromWrong()">ä»é”™é¢˜åº“ç§»é™¤</button>
            <button id="keepInWrongBtn" class="remove-wrong-btn" onclick="keepCurrentWordInWrong()" style="background: #666; margin-left: 10px;">ä¿ç•™åœ¨é”™é¢˜åº“</button>
        </div>
        
        <div class="current-answer">ä½ çš„ç­”æ¡ˆï¼š<span id="currentAnswerText"></span></div>
        
        <form id="answerForm" onsubmit="handleSubmit(event)" style="margin: 0;">
            <input type="search" 
                   id="answer" 
                   placeholder="è¾“å…¥æ—¥è¯­å‡åï¼ˆå®ŒæˆåæŒ‰æœç´¢é”®ï¼‰" 
                   autocomplete="off"
                   autocorrect="off"
                   autocapitalize="off"
                   spellcheck="false"
                   enterkeyhint="search"
                   onblur="handleInputBlur()"
                   x-webkit-speech>
        </form>
        
        <div class="primary-actions">
            <button class="primary-btn check" onclick="checkAnswer()">âœ“ æ£€æŸ¥ç­”æ¡ˆ</button>
            <button class="primary-btn next" onclick="nextWord()">â¡ ä¸‹ä¸€ä¸ª</button>
        </div>
        
        <div class="bottom-actions">
            <button onclick="startPractice()" class="btn-start">å¼€å§‹ç»ƒä¹ </button>
            <button onclick="resetPractice()" class="btn-reset">é‡æ–°å¼€å§‹</button>
            <button onclick="markWrong()" class="btn-mark">æ ‡è®°é”™é¢˜</button>
        </div>
    </div>
    
    <!-- é”™é¢˜é¡µé¢ -->
    <div id="wrong" class="page">
        <h2>é”™é¢˜é›†</h2>
        <div id="wrongList">æš‚æ— é”™é¢˜</div>
        <button onclick="clearWrong()">æ¸…ç©ºé”™é¢˜</button>
        <button onclick="practiceWrong()" style="background:#ff9800;">ç»ƒä¹ é”™é¢˜</button>
    </div>
    
    <!-- ç®¡ç†é¡µé¢ -->
    <div id="manage" class="page">
        <h2>å•è¯ç®¡ç†</h2>
        
        <div class="settings">
            <h3>è¯åº“ä¿¡æ¯</h3>
            <p>å½“å‰è¯åº“æ€»æ•°ï¼š<span id="deckCount">0</span></p>
            <p>å½“å‰å•è¯æ€»æ•°ï¼š<span id="wordCount">0</span></p>
        </div>
        
        <h3>æ·»åŠ æ–°å•è¯</h3>
        <div class="import-controls">
            <label>é€‰æ‹©è¯åº“åˆ†ç±»ï¼š</label>
            <select id="addWordBookSelect"></select>
            <select id="addWordUnitSelect"></select>
        </div>
        <input type="text" id="newChinese" placeholder="ä¸­æ–‡">
        <input type="text" id="newJapanese" placeholder="æ—¥è¯­å‡å">
        <button onclick="addWord()">æ·»åŠ åˆ°é€‰å®šè¯åº“</button>
        
        <h3>æ‰¹é‡å¯¼å…¥</h3>
        <div class="import-controls">
            <label>å¯¼å…¥åˆ°è¯åº“ï¼š</label>
            <select id="importBookSelect"></select>
            <select id="importUnitSelect"></select>
            <button onclick="createNewDeckForImport()" style="background:#4CAF50; margin-left:10px;">æ–°å»ºè¯åº“</button>
        </div>
        <p><strong>ä»Excelå¤åˆ¶ä¸¤åˆ—æ•°æ®ï¼šä¸­æ–‡å’Œæ—¥è¯­å‡å</strong></p>
        <textarea id="importData" placeholder="æ ¼å¼ï¼š
ä½ å¥½    ã“ã‚“ã«ã¡ã¯
è°¢è°¢    ã‚ã‚ŠãŒã¨ã†
æ—©ä¸Šå¥½   ãŠã¯ã‚ˆã†"></textarea>
        <button onclick="importFromExcel()">å¯¼å…¥åˆ°é€‰å®šè¯åº“</button>
        
        <h3>æ‰€æœ‰å•è¯ (<span id="totalWordCount">0</span>)</h3>
        <div id="wordList"></div>
    </div>
    
    <!-- è¯åº“ç®¡ç†é¡µé¢ -->
    <div id="decks" class="page">
        <h2>è¯åº“ç®¡ç†</h2>
        
        <div class="deck-manager">
            <div class="deck-section">
                <h3>ğŸ“š ä¹¦æœ¬åˆ—è¡¨</h3>
                <div class="deck-list" id="bookList">
                    <!-- ä¹¦æœ¬å¡ç‰‡å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                </div>
                <button onclick="createNewBook()" style="background:#4CAF50;">+ æ–°å»ºä¹¦æœ¬</button>
            </div>
            
            <div class="deck-section">
                <h3>ğŸ“– å•å…ƒåˆ—è¡¨</h3>
                <div class="deck-list" id="unitList">
                    <!-- å•å…ƒå¡ç‰‡å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                </div>
                <button onclick="createNewUnit()" style="background:#2196F3;">+ æ–°å»ºå•å…ƒ</button>
            </div>
            
            <div class="deck-section">
                <h3>ğŸ—‘ï¸ åˆ é™¤è¯åº“</h3>
                <p><strong>æ–¹æ¡ˆ1ï¼šé€šè¿‡é€‰æ‹©åˆ é™¤</strong></p>
                <div style="margin: 10px 0;">
                    <label>é€‰æ‹©ä¹¦æœ¬ï¼š</label>
                    <select id="deleteBookSelect"></select>
                    <button onclick="deleteSelectedBook()" class="btn-delete">åˆ é™¤é€‰å®šä¹¦æœ¬</button>
                </div>
                <div style="margin: 10px 0;">
                    <label>é€‰æ‹©å•å…ƒï¼š</label>
                    <select id="deleteUnitSelect"></select>
                    <button onclick="deleteSelectedUnit()" class="btn-delete">åˆ é™¤é€‰å®šå•å…ƒ</button>
                </div>
                
                <p style="margin-top: 20px;"><strong>æ–¹æ¡ˆ2ï¼šé€šè¿‡ä¸Šä¼ è®°å½•åˆ é™¤</strong></p>
                <div class="upload-history" id="uploadHistory">
                    <!-- ä¸Šä¼ è®°å½•å°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
                </div>
            </div>
            
            <div class="deck-section">
                <h3>ğŸ” è¯åº“ç»Ÿè®¡</h3>
                <div id="deckStatistics">
                    <!-- ç»Ÿè®¡ä¿¡æ¯å°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- åŒæ­¥é¡µé¢ (å·²æ›´æ–°ä¸ºGitHubåœ¨çº¿ç‰ˆ) -->
    <div id="sync" class="page">
        <h2>æ•°æ®åŒæ­¥ (GitHubåœ¨çº¿ç‰ˆ)</h2>
        
        <div class="settings">
            <h3>ğŸŒ GitHubåœ¨çº¿åŒæ­¥</h3>
            
            <div id="githubSyncSection" style="background:#e8f5e9; padding:15px; border-radius:8px; margin:15px 0;">
                <p><strong>é¦–æ¬¡ä½¿ç”¨è¯·æŒ‰é¡ºåºæ“ä½œï¼š</strong></p>
                
                <!-- ç¬¬1æ­¥ï¼šè¾“å…¥GitHubä¿¡æ¯ -->
                <div style="margin:15px 0;">
                    <h4>æ­¥éª¤1ï¼šè¾“å…¥GitHubä¿¡æ¯</h4>
                    <p><small>éœ€è¦å…ˆåˆ›å»ºGitHubè´¦å·å’ŒPersonal Access Token</small></p>
                    <input type="text" id="githubUsername" placeholder="GitHubç”¨æˆ·å" style="width:80%; padding:8px; margin:5px 0;">
                    <input type="password" id="githubToken" placeholder="GitHub Personal Access Token" style="width:80%; padding:8px; margin:5px 0;">
                    <p><small><a href="https://github.com/settings/tokens" target="_blank">å¦‚ä½•è·å–Tokenï¼Ÿ</a></small></p>
                    <button onclick="saveGithubConfig()" style="background:#4CAF50;">ä¿å­˜GitHubé…ç½®</button>
                </div>
                
                <!-- ç¬¬2æ­¥ï¼šä¸Šä¼ æ•°æ® -->
                <div style="margin:15px 0; border-top:1px solid #ccc; padding-top:15px;">
                    <h4>æ­¥éª¤2ï¼šä¸Šä¼ æ•°æ®åˆ°GitHub</h4>
                    <p>å°†å½“å‰æ•°æ®ä¸Šä¼ åˆ°GitHub Gistï¼ˆäº‘ç«¯å­˜å‚¨ï¼‰</p>
                    <button onclick="uploadToGithub()" style="background:#2196F3;">ğŸ“¤ ä¸Šä¼ åˆ°GitHub</button>
                    <div id="uploadStatus" style="margin-top:10px;"></div>
                </div>
                
                <!-- ç¬¬3æ­¥ï¼šä¸‹è½½æ•°æ® -->
                <div style="margin:15px 0; border-top:1px solid #ccc; padding-top:15px;">
                    <h4>æ­¥éª¤3ï¼šä»GitHubä¸‹è½½æ•°æ®</h4>
                    <p>åœ¨å…¶ä»–è®¾å¤‡ä¸Šä½¿ç”¨æ­¤åŠŸèƒ½ä¸‹è½½æ•°æ®</p>
                    <button onclick="downloadFromGithub()" style="background:#FF9800;">ğŸ“¥ ä»GitHubä¸‹è½½</button>
                    <div id="downloadStatus" style="margin-top:10px;"></div>
                </div>
                
                <!-- æ˜¾ç¤ºåŒæ­¥çŠ¶æ€ -->
                <div style="margin-top:20px; padding:10px; background:#f5f5f5; border-radius:5px;">
                    <h4>ğŸ“Š åŒæ­¥çŠ¶æ€</h4>
                    <div id="syncStatus">
                        æœªé…ç½®GitHubåŒæ­¥
                    </div>
                    <div id="lastSyncTime">
                        ä¸Šæ¬¡åŒæ­¥æ—¶é—´ï¼šä»æœªåŒæ­¥
                    </div>
                </div>
            </div>
            
            <div style="border-top:1px solid #ccc; margin-top:20px; padding-top:20px;">
                <h3>æ—§ç‰ˆå¯¼å‡º/å¯¼å…¥ï¼ˆå¤‡ç”¨ï¼‰</h3>
                <p><strong>æ­¥éª¤1ï¼š</strong> åœ¨ç”µè„‘ä¸Šç‚¹å‡»ä¸‹é¢çš„"å¯¼å‡ºæ•°æ®"æŒ‰é’®</p>
                <p><strong>æ­¥éª¤2ï¼š</strong> å°†ç”Ÿæˆçš„æ–‡æœ¬æ–‡ä»¶å‘é€åˆ°æ‰‹æœºï¼ˆå¾®ä¿¡ã€QQã€é‚®ä»¶ï¼‰</p>
                <p><strong>æ­¥éª¤3ï¼š</strong> åœ¨æ‰‹æœºæµè§ˆå™¨ä¸­æ‰“å¼€æ­¤é¡µé¢ï¼Œç‚¹å‡»"é€‰æ‹©æ–‡ä»¶"å¯¼å…¥</p>
                <button onclick="exportData()">å¯¼å‡ºæ•°æ®ï¼ˆç”Ÿæˆæ–‡ä»¶ï¼‰</button>
            </div>
            
            <div class="settings">
                <h3>å¯¼å…¥æ•°æ®ï¼ˆåœ¨æ‰‹æœºä¸Šï¼‰</h3>
                <p>é€‰æ‹©ä»ç”µè„‘å¯¼å‡ºçš„æ•°æ®æ–‡ä»¶ï¼š</p>
                <input type="file" id="fileInput" accept=".txt,.json">
                <button onclick="importData()">å¯¼å…¥æ•°æ®</button>
            </div>
            
            <div style="margin-top: 20px;">
                <button onclick="clearAllData()" style="background:red;">æ¸…ç©ºæ‰€æœ‰æ•°æ®</button>
            </div>
        </div>
    </div>

    <!-- ç¼–è¾‘å•è¯æ¨¡æ€æ¡† -->
    <div id="editOverlay" class="overlay" style="display:none;"></div>
    <div id="editForm" class="edit-form" style="display:none;">
        <button class="close-btn" onclick="closeEditForm()">Ã—</button>
        <h3>ç¼–è¾‘å•è¯</h3>
        <div class="form-group">
            <label>ä¸­æ–‡ï¼š</label>
            <input type="text" id="editChinese" style="width:100%;">
        </div>
        <div class="form-group">
            <label>æ—¥è¯­å‡åï¼š</label>
            <input type="text" id="editJapanese" style="width:100%;">
        </div>
        <div class="form-group">
            <label>ä¹¦æœ¬ï¼š</label>
            <select id="editBookSelect"></select>
        </div>
        <div class="form-group">
            <label>å•å…ƒï¼š</label>
            <select id="editUnitSelect"></select>
        </div>
        <div class="form-group">
            <button onclick="saveEditedWord()" style="background:#4CAF50; width:100%;">ä¿å­˜ä¿®æ”¹</button>
        </div>
    </div>

    <!-- åˆ›å»ºè¯åº“æ¨¡æ€æ¡† -->
    <div id="createDeckOverlay" class="overlay" style="display:none;"></div>
    <div id="createDeckForm" class="edit-form" style="display:none;">
        <button class="close-btn" onclick="closeCreateDeckForm()">Ã—</button>
        <h3 id="createDeckTitle">æ–°å»ºè¯åº“</h3>
        <div class="form-group">
            <label>åç§°ï¼š</label>
            <input type="text" id="newDeckName" style="width:100%;" placeholder="è¾“å…¥è¯åº“åç§°">
        </div>
        <div class="form-group" id="parentBookGroup" style="display:none;">
            <label>æ‰€å±ä¹¦æœ¬ï¼š</label>
            <select id="parentBookSelect"></select>
        </div>
        <div class="form-group">
            <button onclick="saveNewDeck()" style="background:#4CAF50; width:100%;" id="saveDeckButton">åˆ›å»º</button>
        </div>
    </div>

    <script>
        // ==================== æ ¸å¿ƒæ•°æ®ç»“æ„ ====================
        let allVocabularies = [];
        let allDecks = [];
        let wrongWords = [];
        let practiceWords = [];
        let currentIndex = 0;
        let settings = { practiceCount: 30 };
        let practiceStats = { total: 0, correct: 0, wrong: 0 };
        let isAnswerChecked = false;
        let isMobile = false;
        let uploadHistory = [];
        let currentDeckAction = 'create'; // 'create' æˆ– 'edit'
        let currentDeckId = null;
        
        // é”™é¢˜ç»ƒä¹ ç›¸å…³å˜é‡
        let currentWrongWordIndex = null; // å½“å‰ç»ƒä¹ çš„å•è¯åœ¨é”™é¢˜åº“ä¸­çš„ç´¢å¼•
        let isWrongPracticeMode = false; // æ˜¯å¦åœ¨é”™é¢˜ç»ƒä¹ æ¨¡å¼
        
        // GitHubåŒæ­¥é…ç½®
        let githubConfig = {
            username: '',
            token: '',
            gistId: ''
        };

        // ==================== é¡µé¢åŠ è½½ ====================
        window.onload = function() {
            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            loadData();
            loadSettings();
            loadGithubConfig(); // æ–°å¢ï¼šåŠ è½½GitHubé…ç½®
            initAllSelectors();
            
            const answerInput = document.getElementById('answer');
            const answerForm = document.getElementById('answerForm');
            
            answerForm.addEventListener('submit', function(event) {
                event.preventDefault();
                handleFormSubmit();
                return false;
            });
            
            answerInput.addEventListener('keydown', function(event) {
                if (event.key === 'Enter' || event.keyCode === 13) {
                    event.preventDefault();
                    if (!isAnswerChecked) {
                        checkAnswer();
                    } else {
                        nextWord();
                    }
                    return false;
                }
            });
            
            answerInput.addEventListener('input', function(event) {
                if (!isMobile) {
                    document.getElementById('currentAnswerText').textContent = this.value;
                }
            });
            
            if (practiceWords.length > 0) {
                showQuestion();
            }
            
            // åˆå§‹æ˜¾ç¤ºè¯åº“ç»Ÿè®¡
            updateDeckStatistics();
            renderDeckCards();
            updateSyncStatus(); // æ–°å¢ï¼šæ›´æ–°åŒæ­¥çŠ¶æ€æ˜¾ç¤º
        };
        
        // ==================== æ•°æ®åŠ è½½å’Œä¿å­˜ ====================
        function loadData() {
            // åŠ è½½è¯åº“æ•°æ®
            if (localStorage.getItem('japaneseDecks')) {
                allDecks = JSON.parse(localStorage.getItem('japaneseDecks'));
            }
            
            // åŠ è½½å•è¯æ•°æ®
            if (localStorage.getItem('japaneseVocabularies')) {
                allVocabularies = JSON.parse(localStorage.getItem('japaneseVocabularies'));
            }
            
            // åŠ è½½ä¸Šä¼ å†å²
            if (localStorage.getItem('uploadHistory')) {
                uploadHistory = JSON.parse(localStorage.getItem('uploadHistory'));
            }
            
            // æ—§ç‰ˆæœ¬æ•°æ®è¿ç§»
            if (localStorage.getItem('japaneseWords') && allVocabularies.length === 0) {
                const oldWords = JSON.parse(localStorage.getItem('japaneseWords'));
                if (oldWords && oldWords.length > 0) {
                    alert('æ£€æµ‹åˆ°æ—§ç‰ˆæœ¬å•è¯æ•°æ®ï¼Œæ­£åœ¨è‡ªåŠ¨è¿ç§»åˆ°æ–°ç‰ˆæœ¬...');
                    const defaultBookName = "æˆ‘çš„é»˜è®¤è¯åº“";
                    const defaultUnitName = "é»˜è®¤å•å…ƒ";
                    
                    let defaultBook = allDecks.find(d => d.name === defaultBookName && d.type === 'book');
                    if (!defaultBook) {
                        defaultBook = { 
                            id: generateId(), 
                            name: defaultBookName, 
                            type: 'book',
                            createdAt: new Date().toISOString()
                        };
                        allDecks.push(defaultBook);
                    }
                    
                    let defaultUnit = allDecks.find(d => d.name === defaultUnitName && d.parentId === defaultBook.id);
                    if (!defaultUnit) {
                        defaultUnit = { 
                            id: generateId(), 
                            name: defaultUnitName, 
                            parentId: defaultBook.id, 
                            type: 'unit',
                            createdAt: new Date().toISOString()
                        };
                        allDecks.push(defaultUnit);
                    }
                    
                    allVocabularies = oldWords.map(word => ({
                        ...word,
                        deckId: defaultUnit.id,
                        book: defaultBookName,
                        unit: defaultUnitName,
                        createdAt: new Date().toISOString()
                    }));
                    
                    // è®°å½•ä¸Šä¼ å†å²
                    uploadHistory.push({
                        type: 'migration',
                        book: defaultBookName,
                        unit: defaultUnitName,
                        count: allVocabularies.length,
                        date: new Date().toISOString()
                    });
                    
                    saveData();
                    alert(`è¿ç§»å®Œæˆï¼å…±è¿ç§» ${allVocabularies.length} ä¸ªå•è¯åˆ°"${defaultBookName} - ${defaultUnitName}"ã€‚`);
                }
            }
            
            // åŠ è½½å…¶ä»–æ•°æ®
            if (localStorage.getItem('wrongWords')) {
                wrongWords = JSON.parse(localStorage.getItem('wrongWords'));
            }
            if (localStorage.getItem('practiceStats')) {
                practiceStats = JSON.parse(localStorage.getItem('practiceStats'));
            }
            
            updateCounts();
        }
        
        function saveData() {
            localStorage.setItem('japaneseDecks', JSON.stringify(allDecks));
            localStorage.setItem('japaneseVocabularies', JSON.stringify(allVocabularies));
            localStorage.setItem('wrongWords', JSON.stringify(wrongWords));
            localStorage.setItem('practiceStats', JSON.stringify(practiceStats));
            localStorage.setItem('uploadHistory', JSON.stringify(uploadHistory));
            updateCounts();
        }
        
        function generateId() {
            return Date.now() + Math.floor(Math.random() * 1000);
        }
        
        // ==================== GitHub åŒæ­¥åŠŸèƒ½ ====================
        // åŠ è½½GitHubé…ç½®
        function loadGithubConfig() {
            if (localStorage.getItem('githubConfig')) {
                githubConfig = JSON.parse(localStorage.getItem('githubConfig'));
            }
        }

        // ä¿å­˜GitHubé…ç½®
        function saveGithubConfig() {
            const username = document.getElementById('githubUsername').value.trim();
            const token = document.getElementById('githubToken').value.trim();
            
            if (!username || !token) {
                alert('è¯·å¡«å†™GitHubç”¨æˆ·åå’ŒToken');
                return;
            }
            
            githubConfig.username = username;
            githubConfig.token = token;
            
            localStorage.setItem('githubConfig', JSON.stringify(githubConfig));
            updateSyncStatus();
            alert('GitHubé…ç½®ä¿å­˜æˆåŠŸï¼');
        }

        // æ›´æ–°åŒæ­¥çŠ¶æ€æ˜¾ç¤º
        function updateSyncStatus() {
            const statusDiv = document.getElementById('syncStatus');
            const lastSyncDiv = document.getElementById('lastSyncTime');
            const lastSync = localStorage.getItem('lastSyncTime');
            
            if (githubConfig.username && githubConfig.token) {
                statusDiv.innerHTML = `âœ… GitHubå·²é…ç½®<br>ç”¨æˆ·å: ${githubConfig.username}`;
                // è‡ªåŠ¨å¡«å……è¾“å…¥æ¡†
                document.getElementById('githubUsername').value = githubConfig.username;
                // æ³¨æ„ï¼šå‡ºäºå®‰å…¨è€ƒè™‘ï¼Œæˆ‘ä»¬ä¸è‡ªåŠ¨å¡«å……token
            } else {
                statusDiv.innerHTML = 'âŒ GitHubæœªé…ç½®';
            }
            
            if (lastSync) {
                lastSyncDiv.innerHTML = `ä¸Šæ¬¡åŒæ­¥æ—¶é—´: ${new Date(lastSync).toLocaleString()}`;
            } else {
                lastSyncDiv.innerHTML = 'ä¸Šæ¬¡åŒæ­¥æ—¶é—´ï¼šä»æœªåŒæ­¥';
            }
        }

        // ä¸Šä¼ æ•°æ®åˆ°GitHub
        async function uploadToGithub() {
            if (!githubConfig.username || !githubConfig.token) {
                alert('è¯·å…ˆé…ç½®GitHubç”¨æˆ·åå’ŒToken');
                return;
            }
            
            const uploadStatus = document.getElementById('uploadStatus');
            uploadStatus.innerHTML = 'æ­£åœ¨ä¸Šä¼ æ•°æ®åˆ°GitHub...';
            
            try {
                // å‡†å¤‡æ•°æ®
                const allData = {
                    allDecks: allDecks,
                    allVocabularies: allVocabularies,
                    wrongWords: wrongWords,
                    uploadHistory: uploadHistory,
                    settings: settings,
                    practiceStats: practiceStats,
                    exportDate: new Date().toISOString()
                };
                
                const dataStr = JSON.stringify(allData, null, 2);
                const filename = `japanese_vocab_backup_${new Date().toISOString().slice(0,10)}.json`;
                
                // åˆ›å»ºæˆ–æ›´æ–°Gist
                let gistId = githubConfig.gistId;
                
                if (gistId) {
                    // æ›´æ–°ç°æœ‰çš„Gist
                    await updateGist(gistId, filename, dataStr);
                } else {
                    // åˆ›å»ºæ–°çš„Gist
                    gistId = await createGist(filename, dataStr);
                    githubConfig.gistId = gistId;
                    localStorage.setItem('githubConfig', JSON.stringify(githubConfig));
                }
                
                // ä¿å­˜åŒæ­¥æ—¶é—´
                localStorage.setItem('lastSyncTime', new Date().toISOString());
                
                uploadStatus.innerHTML = `âœ… ä¸Šä¼ æˆåŠŸï¼<br>Gist ID: ${gistId}<br>æ•°æ®å·²å®‰å…¨ä¿å­˜åˆ°GitHub`;
                updateSyncStatus();
                
            } catch (error) {
                console.error('ä¸Šä¼ å¤±è´¥:', error);
                uploadStatus.innerHTML = `âŒ ä¸Šä¼ å¤±è´¥: ${error.message}<br>è¯·æ£€æŸ¥Tokenæ˜¯å¦æœ‰gistæƒé™`;
            }
        }

        // ä»GitHubä¸‹è½½æ•°æ®
        async function downloadFromGithub() {
            if (!githubConfig.username || !githubConfig.token) {
                alert('è¯·å…ˆé…ç½®GitHubç”¨æˆ·åå’ŒToken');
                return;
            }
            
            const downloadStatus = document.getElementById('downloadStatus');
            downloadStatus.innerHTML = 'æ­£åœ¨ä»GitHubä¸‹è½½æ•°æ®...';
            
            try {
                let gistId = githubConfig.gistId;
                
                // å¦‚æœæ²¡æœ‰gistIdï¼Œå°è¯•æŸ¥æ‰¾ç”¨æˆ·çš„gists
                if (!gistId) {
                    const gists = await listUserGists();
                    if (gists.length === 0) {
                        throw new Error('æ²¡æœ‰æ‰¾åˆ°å·²ä¿å­˜çš„æ•°æ®ï¼Œè¯·å…ˆä¸Šä¼ æ•°æ®');
                    }
                    // ä½¿ç”¨æœ€æ–°çš„ä¸€ä¸ªgist
                    gistId = gists[0].id;
                    githubConfig.gistId = gistId;
                    localStorage.setItem('githubConfig', JSON.stringify(githubConfig));
                }
                
                // è·å–gistæ•°æ®
                const gistData = await getGist(gistId);
                
               // æŸ¥æ‰¾åŒ…å«æ—¥è¯­å•è¯æ•°æ®çš„æ–‡ä»¶ï¼Œå¹¶é€‰æ‹©æœ€æ–°çš„ä¸€ä¸ª
let dataFile = null;
let latestFile = null;
let latestDate = null;
for (const filename in gistData.files) {
    if (filename.includes('japanese_vocab_backup')) {
        const file = gistData.files[filename];
        const dateMatch = filename.match(/(\d{4})-(\d{2})-(\d{2})/);
        let fileDate = null;
        if (dateMatch) {
            fileDate = new Date(dateMatch[1], dateMatch[2] - 1, dateMatch[3]).getTime();
        } else {
            fileDate = new Date(file.updated_at || gistData.updated_at).getTime();
        }
        if (latestDate === null || fileDate > latestDate) {
            latestDate = fileDate;
            latestFile = file;
        }
    }
}
dataFile = latestFile;
                
                if (!dataFile || !dataFile.content) {
                    throw new Error('æœªæ‰¾åˆ°å•è¯æ•°æ®æ–‡ä»¶');
                }
                
                // è§£ææ•°æ®
                const allData = JSON.parse(dataFile.content);
                
                // ç¡®è®¤æ˜¯å¦è¦†ç›–
                if (!confirm(`ä»äº‘ç«¯ä¸‹è½½æ•°æ®å°†è¦†ç›–å½“å‰æ•°æ®ï¼Œç¡®å®šè¦ç»§ç»­å—ï¼Ÿ\n\nä¸‹è½½æ—¶é—´: ${new Date(allData.exportDate).toLocaleString()}\nå•è¯æ•°é‡: ${allData.allVocabularies?.length || 0}`)) {
                    return;
                }
                
                // åŠ è½½æ•°æ®
                allDecks = allData.allDecks || [];
                allVocabularies = allData.allVocabularies || [];
                wrongWords = allData.wrongWords || [];
                uploadHistory = allData.uploadHistory || [];
                settings = allData.settings || { practiceCount: 30 };
                practiceStats = allData.practiceStats || { total: 0, correct: 0, wrong: 0 };
                
                saveData();
                loadSettings();
                initAllSelectors();
                showWordList();
                showWrongList();
                renderDeckCards();
                updateDeckStatistics();
                renderUploadHistory();
                
                // ä¿å­˜åŒæ­¥æ—¶é—´
                localStorage.setItem('lastSyncTime', new Date().toISOString());
                
                downloadStatus.innerHTML = `âœ… ä¸‹è½½æˆåŠŸï¼<br>å…±åŠ è½½ ${allVocabularies.length} ä¸ªå•è¯<br>${wrongWords.length} ä¸ªé”™é¢˜`;
                updateSyncStatus();
                
                alert(`æ•°æ®åŒæ­¥å®Œæˆï¼
        - ${allDecks.length} ä¸ªè¯åº“
        - ${allVocabularies.length} ä¸ªå•è¯
        - ${wrongWords.length} ä¸ªé”™é¢˜
        å·²æˆåŠŸåŠ è½½åˆ°å½“å‰è®¾å¤‡ï¼`);
                
            } catch (error) {
                console.error('ä¸‹è½½å¤±è´¥:', error);
                downloadStatus.innerHTML = `âŒ ä¸‹è½½å¤±è´¥: ${error.message}`;
            }
        }

        // GitHub API è¾…åŠ©å‡½æ•°
        async function createGist(filename, content) {
            const response = await fetch('https://api.github.com/gists', {
                method: 'POST',
                headers: {
                    'Authorization': `token ${githubConfig.token}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    description: 'æ—¥è¯­å•è¯å·¥å…·æ•°æ®å¤‡ä»½',
                    public: false,
                    files: {
                        [filename]: {
                            content: content
                        }
                    }
                })
            });
            
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || 'åˆ›å»ºGistå¤±è´¥');
            }
            
            const data = await response.json();
            return data.id;
        }

        async function updateGist(gistId, filename, content) {
            const response = await fetch(`https://api.github.com/gists/${gistId}`, {
                method: 'PATCH',
                headers: {
                    'Authorization': `token ${githubConfig.token}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    description: `æ—¥è¯­å•è¯å·¥å…·æ•°æ®å¤‡ä»½ - æ›´æ–°äº ${new Date().toLocaleString()}`,
                    files: {
                        [filename]: {
                            content: content
                        }
                    }
                })
            });
            
            if (!response.ok) {
                throw new Error('æ›´æ–°Gistå¤±è´¥');
            }
        }

        async function getGist(gistId) {
            const response = await fetch(`https://api.github.com/gists/${gistId}`, {
                headers: {
                    'Authorization': `token ${githubConfig.token}`
                }
            });
            
            if (!response.ok) {
                throw new Error('è·å–Gistå¤±è´¥');
            }
            
            return await response.json();
        }

        async function listUserGists() {
            const response = await fetch(`https://api.github.com/users/${githubConfig.username}/gists`, {
                headers: {
                    'Authorization': `token ${githubConfig.token}`
                }
            });
            
            if (!response.ok) {
                throw new Error('è·å–Giståˆ—è¡¨å¤±è´¥');
            }
            
            return await response.json();
        }
        
        // ==================== åˆå§‹åŒ–æ‰€æœ‰ä¸‹æ‹‰é€‰æ‹©å™¨ ====================
        function initAllSelectors() {
            fillBookSelect();
            fillUnitSelect();
            fillAddWordSelectors();
            fillImportSelectors();
            fillDeleteSelectors();
            fillEditSelectors();
            renderUploadHistory();
        }
        
        function fillBookSelect() {
            const bookSelect = document.getElementById('bookSelect');
            bookSelect.innerHTML = '<option value="">è¯·é€‰æ‹©ä¹¦æœ¬</option>';
            const books = allDecks.filter(deck => deck.type === 'book');
            books.forEach(book => {
                const option = document.createElement('option');
                option.value = book.id;
                option.textContent = book.name;
                bookSelect.appendChild(option);
            });
        }
        
        function fillUnitSelect(bookId = null) {
            const unitSelect = document.getElementById('unitSelect');
            unitSelect.innerHTML = '<option value="">è¯·é€‰æ‹©å•å…ƒ</option>';
            
            let units = [];
            if (bookId) {
                units = allDecks.filter(deck => deck.type === 'unit' && deck.parentId == bookId);
            } else {
                units = allDecks.filter(deck => deck.type === 'unit');
            }
            
            units.forEach(unit => {
                const option = document.createElement('option');
                option.value = unit.id;
                option.textContent = unit.name;
                unitSelect.appendChild(option);
            });
        }
        
        function fillAddWordSelectors() {
            const bookSelect = document.getElementById('addWordBookSelect');
            const unitSelect = document.getElementById('addWordUnitSelect');
            
            bookSelect.innerHTML = '<option value="">è¯·é€‰æ‹©ä¹¦æœ¬</option>';
            unitSelect.innerHTML = '<option value="">è¯·é€‰æ‹©å•å…ƒ</option>';
            
            const books = allDecks.filter(deck => deck.type === 'book');
            books.forEach(book => {
                const option = document.createElement('option');
                option.value = book.id;
                option.textContent = book.name;
                bookSelect.appendChild(option);
            });
            
            // å½“ä¹¦æœ¬æ”¹å˜æ—¶ï¼Œæ›´æ–°å•å…ƒé€‰æ‹©
            bookSelect.onchange = function() {
                const selectedBookId = this.value;
                fillUnitSelectorsByBook(selectedBookId, unitSelect);
            };
        }
        
        function fillImportSelectors() {
            const bookSelect = document.getElementById('importBookSelect');
            const unitSelect = document.getElementById('importUnitSelect');
            
            bookSelect.innerHTML = '<option value="">è¯·é€‰æ‹©ä¹¦æœ¬</option>';
            unitSelect.innerHTML = '<option value="">è¯·é€‰æ‹©å•å…ƒ</option>';
            
            const books = allDecks.filter(deck => deck.type === 'book');
            books.forEach(book => {
                const option = document.createElement('option');
                option.value = book.id;
                option.textContent = book.name;
                bookSelect.appendChild(option);
            });
            
            bookSelect.onchange = function() {
                const selectedBookId = this.value;
                fillUnitSelectorsByBook(selectedBookId, unitSelect);
            };
        }
        
        function fillDeleteSelectors() {
            const deleteBookSelect = document.getElementById('deleteBookSelect');
            const deleteUnitSelect = document.getElementById('deleteUnitSelect');
            
            deleteBookSelect.innerHTML = '<option value="">è¯·é€‰æ‹©ä¹¦æœ¬</option>';
            deleteUnitSelect.innerHTML = '<option value="">è¯·é€‰æ‹©å•å…ƒ</option>';
            
            const books = allDecks.filter(deck => deck.type === 'book');
            books.forEach(book => {
                const option = document.createElement('option');
                option.value = book.id;
                option.textContent = book.name;
                deleteBookSelect.appendChild(option);
            });
            
            deleteBookSelect.onchange = function() {
                const selectedBookId = this.value;
                const units = allDecks.filter(deck => deck.type === 'unit' && deck.parentId == selectedBookId);
                deleteUnitSelect.innerHTML = '<option value="">è¯·é€‰æ‹©å•å…ƒ</option>';
                units.forEach(unit => {
                    const option = document.createElement('option');
                    option.value = unit.id;
                    option.textContent = unit.name;
                    deleteUnitSelect.appendChild(option);
                });
            };
        }
        
        function fillEditSelectors() {
            const editBookSelect = document.getElementById('editBookSelect');
            const editUnitSelect = document.getElementById('editUnitSelect');
            
            editBookSelect.innerHTML = '<option value="">è¯·é€‰æ‹©ä¹¦æœ¬</option>';
            editUnitSelect.innerHTML = '<option value="">è¯·é€‰æ‹©å•å…ƒ</option>';
            
            const books = allDecks.filter(deck => deck.type === 'book');
            books.forEach(book => {
                const option = document.createElement('option');
                option.value = book.id;
                option.textContent = book.name;
                editBookSelect.appendChild(option);
            });
            
            editBookSelect.onchange = function() {
                const selectedBookId = this.value;
                fillUnitSelectorsByBook(selectedBookId, editUnitSelect);
            };
        }
        
        function fillUnitSelectorsByBook(bookId, unitSelectElement) {
            unitSelectElement.innerHTML = '<option value="">è¯·é€‰æ‹©å•å…ƒ</option>';
            if (!bookId) return;
            
            const units = allDecks.filter(deck => deck.type === 'unit' && deck.parentId == bookId);
            units.forEach(unit => {
                const option = document.createElement('option');
                option.value = unit.id;
                option.textContent = unit.name;
                unitSelectElement.appendChild(option);
            });
        }
        
        // ==================== é¡µé¢åˆ‡æ¢ ====================
        function showPage(pageId) {
            document.querySelectorAll('.page').forEach(page => {
                page.classList.remove('active');
            });
            document.querySelectorAll('.tab button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // è·å–äº‹ä»¶ç›®æ ‡ï¼ˆè¢«ç‚¹å‡»çš„æŒ‰é’®ï¼‰
            let target = event.target;
            // ç¡®ä¿æˆ‘ä»¬æ‰¾åˆ°çš„æ˜¯æŒ‰é’®å…ƒç´ 
            while (target && !target.classList.contains('tab')) {
                if (target.tagName === 'BUTTON') {
                    target.classList.add('active');
                    break;
                }
                target = target.parentElement;
            }
            
            document.getElementById(pageId).classList.add('active');
            
            if (pageId === 'manage') {
                showWordList();
                initAllSelectors();
            } else if (pageId === 'wrong') {
                showWrongList();
            } else if (pageId === 'decks') {
                renderDeckCards();
                updateDeckStatistics();
                renderUploadHistory();
            } else if (pageId === 'sync') {
                updateSyncStatus(); // åˆ‡æ¢åˆ°åŒæ­¥é¡µé¢æ—¶æ›´æ–°çŠ¶æ€
            }
            
            if (pageId === 'practice' && practiceWords.length > 0) {
                setTimeout(() => {
                    document.getElementById('answer').focus();
                }, 100);
            }
        }
        
        // ==================== ç»ƒä¹ åŠŸèƒ½ ====================
        function onPracticeModeChange() {
            const mode = document.getElementById('practiceMode').value;
            const deckSelector = document.getElementById('deckSelectorContainer');
            
            if (mode === 'wrong' || mode === 'all') {
                deckSelector.style.display = 'none';
            } else {
                deckSelector.style.display = 'block';
                const unitWrapper = document.getElementById('unitSelectorWrapper');
                unitWrapper.style.display = mode === 'unit' ? 'block' : 'none';
            }
        }
        
        function onBookSelectChange() {
            const bookId = document.getElementById('bookSelect').value;
            fillUnitSelect(bookId);
        }
        
        function startPractice() {
            const mode = document.getElementById('practiceMode').value;
            let candidateWords = [];
            
            // é‡ç½®é”™é¢˜ç»ƒä¹ æ¨¡å¼çŠ¶æ€
            isWrongPracticeMode = false;
            document.getElementById('wrongRemovalOption').style.display = 'none';
            
            if (mode === 'wrong') {
                // é”™é¢˜ç»ƒä¹ æ¨¡å¼
                isWrongPracticeMode = true;
                candidateWords = wrongWords.map(wrongItem => {
                    return allVocabularies.find(w => 
                        w.chinese === wrongItem.chinese && w.japanese === wrongItem.japanese);
                }).filter(Boolean);
                
                if (candidateWords.length === 0) {
                    alert('æš‚æ— é”™é¢˜ï¼Œè¯·å…ˆè¿›è¡Œç»ƒä¹ å¹¶ç­”é”™ä¸€äº›å•è¯ã€‚');
                    return;
                }
            } else if (mode === 'all') {
                candidateWords = [...allVocabularies];
            } else {
                const bookId = document.getElementById('bookSelect').value;
                if (!bookId) {
                    alert('è¯·å…ˆé€‰æ‹©ä¸€æœ¬ä¹¦ã€‚');
                    return;
                }
                
                const book = allDecks.find(d => d.id == bookId);
                if (!book) return;
                
                if (mode === 'unit') {
                    const unitId = document.getElementById('unitSelect').value;
                    if (!unitId) {
                        alert('è¯·é€‰æ‹©ä¸€ä¸ªå•å…ƒã€‚');
                        return;
                    }
                    
                    const unit = allDecks.find(d => d.id == unitId);
                    if (!unit) return;
                    
                    candidateWords = allVocabularies.filter(word => 
                        word.deckId == unitId);
                } else { // mode === 'review' - æ±‡æ€»ç»ƒä¹ 
                    // ä¿®å¤æ±‡æ€»ç»ƒä¹ çš„å…³é”®ï¼šæ­£ç¡®è·å–è¯¥ä¹¦æœ¬ä¸‹çš„æ‰€æœ‰å•å…ƒ
                    // ä½¿ç”¨ == è€Œä¸æ˜¯ === æ¯”è¾ƒï¼Œå› ä¸º bookId æ˜¯å­—ç¬¦ä¸²ï¼Œè€Œ parentId æ˜¯æ•°å­—
                    const unitIds = allDecks
                        .filter(d => d.type === 'unit' && d.parentId == bookId)
                        .map(u => u.id);
                    
                    if (unitIds.length === 0) {
                        alert('è¯¥ä¹¦æœ¬ä¸‹æ²¡æœ‰æ‰¾åˆ°å•å…ƒï¼Œè¯·å…ˆæ·»åŠ å•å…ƒæˆ–æ£€æŸ¥æ•°æ®ã€‚');
                        return;
                    }
                    
                    // ç­›é€‰å‡ºæ‰€æœ‰å±äºè¿™äº›å•å…ƒçš„å•è¯
                    // ä½¿ç”¨ includes æ£€æŸ¥ word.deckId æ˜¯å¦åœ¨ unitIds ä¸­
                    candidateWords = allVocabularies.filter(word => 
                        unitIds.includes(word.deckId));
                    
                    console.log('æ±‡æ€»ç»ƒä¹ ç»Ÿè®¡ï¼š');
                    console.log('- ä¹¦æœ¬ID:', bookId);
                    console.log('- ä¹¦æœ¬åç§°:', book.name);
                    console.log('- æ‰¾åˆ°çš„å•å…ƒæ•°é‡:', unitIds.length);
                    console.log('- æ‰¾åˆ°çš„å•å…ƒID:', unitIds);
                    console.log('- ç­›é€‰å‡ºçš„å•è¯æ•°é‡:', candidateWords.length);
                    
                    if (candidateWords.length === 0) {
                        // å¦‚æœç­›é€‰ç»“æœä¸ºç©ºï¼Œå¯èƒ½æ˜¯æ•°æ®ä¸ä¸€è‡´é—®é¢˜
                        // å°è¯•ç”¨æ›´å®½æ¾çš„æ–¹å¼æŸ¥æ‰¾
                        console.log('å°è¯•å¤‡ç”¨æŸ¥æ‰¾æ–¹æ³•...');
                        const allUnitWords = [];
                        unitIds.forEach(unitId => {
                            const unitWords = allVocabularies.filter(word => word.deckId == unitId);
                            allUnitWords.push(...unitWords);
                        });
                        candidateWords = allUnitWords;
                        console.log('å¤‡ç”¨æ–¹æ³•æ‰¾åˆ°çš„å•è¯æ•°é‡:', candidateWords.length);
                    }
                }
            }
            
            if (candidateWords.length === 0) {
                alert('å½“å‰ç­›é€‰æ¡ä»¶ä¸‹æ²¡æœ‰æ‰¾åˆ°å•è¯ï¼Œè¯·è°ƒæ•´é€‰æ‹©æˆ–æ·»åŠ å•è¯ã€‚');
                return;
            }
            
            practiceWords = [...candidateWords];
            for (let i = practiceWords.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [practiceWords[i], practiceWords[j]] = [practiceWords[j], practiceWords[i]];
            }
            
            let count = settings.practiceCount;
            if (count > 0 && practiceWords.length > count) {
                practiceWords = practiceWords.slice(0, count);
            }
            
            practiceStats = { total: practiceWords.length, correct: 0, wrong: 0 };
            currentIndex = 0;
            isAnswerChecked = false;
            
            showQuestion();
            updateProgressDisplay();
            updatePracticeStats();
            
            setTimeout(() => {
                document.getElementById('answer').focus();
            }, 300);
        }
        
        function showQuestion() {
            if (practiceWords.length === 0) {
                document.getElementById('question').textContent = 'è¯·å…ˆå¼€å§‹ç»ƒä¹ ';
                clearAnswer();
                return;
            }
            
            const word = practiceWords[currentIndex];
            document.getElementById('question').textContent = word.chinese;
            document.getElementById('question').className = 'word';
            clearAnswer();
            
            // å¦‚æœæ˜¯é”™é¢˜ç»ƒä¹ æ¨¡å¼ï¼Œéšè—ç§»é™¤é€‰é¡¹
            document.getElementById('wrongRemovalOption').style.display = 'none';
            
            isAnswerChecked = false;
            updateProgressDisplay();
            
            setTimeout(() => {
                const answerInput = document.getElementById('answer');
                answerInput.focus();
                if (isMobile) answerInput.click();
            }, 200);
        }
        
        function clearAnswer() {
            document.getElementById('answer').value = '';
            document.getElementById('result').innerHTML = '';
            document.getElementById('currentAnswerText').textContent = '';
        }
        
        function checkAnswer() {
            const answer = document.getElementById('answer').value.trim();
            const word = practiceWords[currentIndex];
            
            if (!answer) {
                document.getElementById('result').innerHTML = '<span style="color:orange">è¯·è¾“å…¥ç­”æ¡ˆ</span>';
                return;
            }
            
            isAnswerChecked = true;
            
            if (answer === word.japanese) {
                showResult('âœ“ æ­£ç¡®ï¼', 'correct', 'correct');
                practiceStats.correct++;
                
                // å¦‚æœæ˜¯é”™é¢˜ç»ƒä¹ æ¨¡å¼
                if (isWrongPracticeMode) {
                    // æ˜¾ç¤ºç§»é™¤é€‰é¡¹
                    document.getElementById('wrongRemovalOption').style.display = 'block';
                    
                    // æ‰¾åˆ°å½“å‰å•è¯åœ¨é”™é¢˜åº“ä¸­çš„ç´¢å¼•
                    currentWrongWordIndex = wrongWords.findIndex(w => 
                        w.chinese === word.chinese && w.japanese === word.japanese);
                } else {
                    // éé”™é¢˜ç»ƒä¹ æ¨¡å¼ï¼Œæ­£å¸¸æ·»åŠ é”™é¢˜ï¼ˆå¦‚æœä¹‹å‰æ˜¯é”™çš„ï¼‰
                    // è¿™é‡Œä¸å¤„ç†ï¼Œå› ä¸ºæ­£ç¡®çš„å•è¯ä¸ä¼šæ·»åŠ åˆ°é”™é¢˜åº“
                }
            } else {
                showResult(`âœ— é”™è¯¯ | æ­£ç¡®ç­”æ¡ˆï¼š${word.japanese}`, 'wrong', 'wrong');
                practiceStats.wrong++;
                addToWrong(word);
            }
            
            document.getElementById('currentAnswerText').textContent = answer;
            updatePracticeStats();
            saveData();
            
            if (isMobile) {
                setTimeout(() => document.getElementById('answer').select(), 100);
            }
        }
        
        // ä»é”™é¢˜åº“ç§»é™¤å½“å‰å•è¯
        function removeCurrentWordFromWrong() {
            if (currentWrongWordIndex !== null && currentWrongWordIndex >= 0) {
                wrongWords.splice(currentWrongWordIndex, 1);
                saveData();
                document.getElementById('wrongRemovalOption').style.display = 'none';
                document.getElementById('result').innerHTML += ' <span style="color:#4CAF50">(å·²ä»é”™é¢˜åº“ç§»é™¤)</span>';
                
                // ä»å½“å‰ç»ƒä¹ åˆ—è¡¨ä¸­ç§»é™¤è¿™ä¸ªå•è¯ï¼Œé¿å…é‡å¤ç»ƒä¹ 
                practiceWords.splice(currentIndex, 1);
                if (practiceWords.length === 0) {
                    // å¦‚æœæ²¡æœ‰æ›´å¤šå•è¯ï¼Œç»“æŸç»ƒä¹ 
                    const correctRate = Math.round((practiceStats.correct / practiceStats.total) * 100);
                    alert(`é”™é¢˜ç»ƒä¹ å®Œæˆï¼\næ­£ç¡®ç‡ï¼š${correctRate}%\næ­£ç¡®ï¼š${practiceStats.correct}ä¸ª\né”™è¯¯ï¼š${practiceStats.wrong}ä¸ª`);
                    currentIndex = 0;
                    showQuestion();
                } else {
                    // å¦‚æœè¿˜æœ‰å•è¯ï¼Œæ˜¾ç¤ºä¸‹ä¸€ä¸ª
                    if (currentIndex >= practiceWords.length) {
                        currentIndex = practiceWords.length - 1;
                    }
                    showQuestion();
                }
            }
        }
        
        // ä¿ç•™åœ¨é”™é¢˜åº“
        function keepCurrentWordInWrong() {
            document.getElementById('wrongRemovalOption').style.display = 'none';
            document.getElementById('result').innerHTML += ' <span style="color:#666">(ä¿ç•™åœ¨é”™é¢˜åº“)</span>';
        }
        
        function showResult(message, resultClass, wordClass) {
            const resultDiv = document.getElementById('result');
            const questionDiv = document.getElementById('question');
            
            resultDiv.innerHTML = message;
            resultDiv.className = `result ${resultClass}`;
            questionDiv.className = `word ${wordClass}`;
        }
        
        function nextWord() {
            if (!isAnswerChecked) {
                checkAnswer();
                return;
            }
            
            currentIndex++;
            if (currentIndex >= practiceWords.length) {
                const correctRate = Math.round((practiceStats.correct / practiceStats.total) * 100);
                alert(`ç»ƒä¹ å®Œæˆï¼\næ­£ç¡®ç‡ï¼š${correctRate}%\næ­£ç¡®ï¼š${practiceStats.correct}ä¸ª\né”™è¯¯ï¼š${practiceStats.wrong}ä¸ª`);
                currentIndex = 0;
            }
            showQuestion();
            updateProgressDisplay();
        }
        
        function resetPractice() {
            if (practiceWords.length === 0) {
                startPractice();
                return;
            }
            if (confirm('é‡æ–°å¼€å§‹å½“å‰ç»ƒä¹ ï¼Ÿ')) {
                currentIndex = 0;
                practiceStats = { total: practiceWords.length, correct: 0, wrong: 0 };
                isAnswerChecked = false;
                showQuestion();
                updatePracticeStats();
                updateProgressDisplay();
                document.getElementById('wrongRemovalOption').style.display = 'none';
            }
        }
        
        function markWrong() {
            const word = practiceWords[currentIndex];
            addToWrong(word);
            const resultDiv = document.getElementById('result');
            resultDiv.innerHTML += ' <span style="color:#ff9800">(å·²æ·»åŠ åˆ°é”™é¢˜é›†)</span>';
            document.getElementById('question').className = 'word wrong';
        }
        
        function addToWrong(word) {
            const existingIndex = wrongWords.findIndex(w => 
                w.chinese === word.chinese && w.japanese === word.japanese);
            
            if (existingIndex >= 0) {
                wrongWords[existingIndex].wrongCount += 1;
                wrongWords[existingIndex].lastWrong = Date.now();
            } else {
                wrongWords.push({
                    chinese: word.chinese,
                    japanese: word.japanese,
                    wrongCount: 1,
                    lastWrong: Date.now()
                });
            }
            
            wrongWords.sort((a, b) => b.wrongCount - a.wrongCount);
            saveData();
        }
        
        // ==================== è¯åº“ç®¡ç†åŠŸèƒ½ ====================
        function createNewBook() {
            currentDeckAction = 'create';
            currentDeckId = null;
            document.getElementById('createDeckTitle').textContent = 'æ–°å»ºä¹¦æœ¬';
            document.getElementById('parentBookGroup').style.display = 'none';
            document.getElementById('newDeckName').value = '';
            document.getElementById('saveDeckButton').textContent = 'åˆ›å»º';
            document.getElementById('createDeckOverlay').style.display = 'block';
            document.getElementById('createDeckForm').style.display = 'block';
        }
        
        function createNewUnit() {
            currentDeckAction = 'create';
            currentDeckId = null;
            const parentBookSelect = document.getElementById('parentBookSelect');
            parentBookSelect.innerHTML = '<option value="">è¯·é€‰æ‹©æ‰€å±ä¹¦æœ¬</option>';
            
            const books = allDecks.filter(deck => deck.type === 'book');
            books.forEach(book => {
                const option = document.createElement('option');
                option.value = book.id;
                option.textContent = book.name;
                parentBookSelect.appendChild(option);
            });
            
            document.getElementById('createDeckTitle').textContent = 'æ–°å»ºå•å…ƒ';
            document.getElementById('parentBookGroup').style.display = 'block';
            document.getElementById('newDeckName').value = '';
            document.getElementById('saveDeckButton').textContent = 'åˆ›å»º';
            document.getElementById('createDeckOverlay').style.display = 'block';
            document.getElementById('createDeckForm').style.display = 'block';
        }
        
        function createNewDeckForImport() {
            currentDeckAction = 'create';
            currentDeckId = null;
            const parentBookSelect = document.getElementById('parentBookSelect');
            parentBookSelect.innerHTML = '<option value="">è¯·é€‰æ‹©æ‰€å±ä¹¦æœ¬</option>';
            
            const books = allDecks.filter(deck => deck.type === 'book');
            books.forEach(book => {
                const option = document.createElement('option');
                option.value = book.id;
                option.textContent = book.name;
                parentBookSelect.appendChild(option);
            });
            
            // è‡ªåŠ¨é€‰æ‹©å½“å‰å¯¼å…¥é€‰æ‹©å™¨ä¸­é€‰æ‹©çš„ä¹¦æœ¬
            const selectedBookId = document.getElementById('importBookSelect').value;
            if (selectedBookId) {
                parentBookSelect.value = selectedBookId;
            }
            
            document.getElementById('createDeckTitle').textContent = 'æ–°å»ºå•å…ƒ';
            document.getElementById('parentBookGroup').style.display = 'block';
            document.getElementById('newDeckName').value = '';
            document.getElementById('saveDeckButton').textContent = 'åˆ›å»º';
            document.getElementById('createDeckOverlay').style.display = 'block';
            document.getElementById('createDeckForm').style.display = 'block';
        }
        
        function saveNewDeck() {
            const name = document.getElementById('newDeckName').value.trim();
            if (!name) {
                alert('è¯·è¾“å…¥è¯åº“åç§°');
                return;
            }
            
            if (currentDeckAction === 'edit' && currentDeckId) {
                // ç¼–è¾‘ç°æœ‰è¯åº“
                const deck = allDecks.find(d => d.id == currentDeckId);
                if (!deck) {
                    alert('è¯åº“ä¸å­˜åœ¨');
                    return;
                }
                
                // æ›´æ–°åç§°
                deck.name = name;
                
                // å¦‚æœæ˜¯å•å…ƒï¼Œè¿˜å¯ä»¥æ›´æ–°çˆ¶ä¹¦æœ¬ï¼ˆè¿™é‡Œæˆ‘ä»¬ä¸å…è®¸æ›´æ”¹çˆ¶ä¹¦æœ¬ï¼Œæ‰€ä»¥ä¸å¤„ç†ï¼‰
                
                saveData();
                initAllSelectors();
                renderDeckCards();
                updateDeckStatistics();
                closeCreateDeckForm();
                alert(`è¯åº“"${name}"ä¿®æ”¹æˆåŠŸï¼`);
            } else {
                // æ–°å»º
                const title = document.getElementById('createDeckTitle').textContent;
                const isBook = title === 'æ–°å»ºä¹¦æœ¬';
                
                let newDeck;
                if (isBook) {
                    newDeck = {
                        id: generateId(),
                        name: name,
                        type: 'book',
                        createdAt: new Date().toISOString()
                    };
                } else {
                    const parentBookId = document.getElementById('parentBookSelect').value;
                    if (!parentBookId) {
                        alert('è¯·é€‰æ‹©æ‰€å±ä¹¦æœ¬');
                        return;
                    }
                    
                    const parentBook = allDecks.find(d => d.id == parentBookId);
                    if (!parentBook) {
                        alert('æ‰€é€‰ä¹¦æœ¬ä¸å­˜åœ¨');
                        return;
                    }
                    
                    newDeck = {
                        id: generateId(),
                        name: name,
                        type: 'unit',
                        parentId: parentBookId,
                        parentName: parentBook.name,
                        createdAt: new Date().toISOString()
                    };
                }
                
                allDecks.push(newDeck);
                saveData();
                initAllSelectors();
                renderDeckCards();
                updateDeckStatistics();
                closeCreateDeckForm();
                alert(`è¯åº“"${name}"åˆ›å»ºæˆåŠŸï¼`);
            }
        }
        
        function closeCreateDeckForm() {
            document.getElementById('createDeckOverlay').style.display = 'none';
            document.getElementById('createDeckForm').style.display = 'none';
            currentDeckAction = 'create';
            currentDeckId = null;
        }
        
        function deleteSelectedBook() {
            const bookId = document.getElementById('deleteBookSelect').value;
            if (!bookId) {
                alert('è¯·é€‰æ‹©è¦åˆ é™¤çš„ä¹¦æœ¬');
                return;
            }
            
            const book = allDecks.find(d => d.id == bookId);
            if (!book) {
                alert('æ‰€é€‰ä¹¦æœ¬ä¸å­˜åœ¨');
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰å…³è”çš„å•å…ƒ
            const relatedUnits = allDecks.filter(d => d.type === 'unit' && d.parentId == bookId);
            const relatedWords = allVocabularies.filter(word => {
                const unit = allDecks.find(d => d.id == word.deckId);
                return unit && unit.parentId == bookId;
            });
            
            let message = `ç¡®å®šè¦åˆ é™¤ä¹¦æœ¬"${book.name}"å—ï¼Ÿ\n`;
            if (relatedUnits.length > 0) {
                message += `è¿™å°†åŒæ—¶åˆ é™¤å…¶ä¸‹çš„ ${relatedUnits.length} ä¸ªå•å…ƒ\n`;
            }
            if (relatedWords.length > 0) {
                message += `ä»¥åŠ ${relatedWords.length} ä¸ªå•è¯\n`;
            }
            
            if (!confirm(message + '\næ­¤æ“ä½œä¸å¯æ’¤é”€ï¼')) {
                return;
            }
            
            // åˆ é™¤å…³è”çš„å•è¯
            allVocabularies = allVocabularies.filter(word => {
                const unit = allDecks.find(d => d.id == word.deckId);
                return !unit || unit.parentId != bookId;
            });
            
            // åˆ é™¤å…³è”çš„å•å…ƒ
            allDecks = allDecks.filter(d => !(d.type === 'unit' && d.parentId == bookId));
            
            // åˆ é™¤ä¹¦æœ¬æœ¬èº«
            allDecks = allDecks.filter(d => d.id != bookId);
            
            saveData();
            initAllSelectors();
            renderDeckCards();
            updateDeckStatistics();
            alert(`ä¹¦æœ¬"${book.name}"å·²åˆ é™¤`);
        }
        
        function deleteSelectedUnit() {
            const unitId = document.getElementById('deleteUnitSelect').value;
            if (!unitId) {
                alert('è¯·é€‰æ‹©è¦åˆ é™¤çš„å•å…ƒ');
                return;
            }
            
            const unit = allDecks.find(d => d.id == unitId);
            if (!unit) {
                alert('æ‰€é€‰å•å…ƒä¸å­˜åœ¨');
                return;
            }
            
            const relatedWords = allVocabularies.filter(word => word.deckId == unitId);
            
            let message = `ç¡®å®šè¦åˆ é™¤å•å…ƒ"${unit.name}"å—ï¼Ÿ\n`;
            if (relatedWords.length > 0) {
                message += `è¿™å°†åŒæ—¶åˆ é™¤å…¶ä¸­çš„ ${relatedWords.length} ä¸ªå•è¯\n`;
            }
            
            if (!confirm(message + '\næ­¤æ“ä½œä¸å¯æ’¤é”€ï¼')) {
                return;
            }
            
            // åˆ é™¤å…³è”çš„å•è¯
            allVocabularies = allVocabularies.filter(word => word.deckId != unitId);
            
            // åˆ é™¤å•å…ƒæœ¬èº«
            allDecks = allDecks.filter(d => d.id != unitId);
            
            saveData();
            initAllSelectors();
            renderDeckCards();
            updateDeckStatistics();
            alert(`å•å…ƒ"${unit.name}"å·²åˆ é™¤`);
        }
        
        function renderDeckCards() {
            // æ¸²æŸ“ä¹¦æœ¬å¡ç‰‡
            const bookList = document.getElementById('bookList');
            const books = allDecks.filter(deck => deck.type === 'book');
            
            bookList.innerHTML = '';
            books.forEach(book => {
                const relatedUnits = allDecks.filter(d => d.type === 'unit' && d.parentId == book.id);
                const wordCount = allVocabularies.filter(word => {
                    const unit = allDecks.find(d => d.id == word.deckId);
                    return unit && unit.parentId == book.id;
                }).length;
                
                const card = document.createElement('div');
                card.className = 'deck-card';
                card.innerHTML = `
                    <h4>${book.name}</h4>
                    <div class="deck-stats">
                        <div>å•å…ƒæ•°: ${relatedUnits.length}</div>
                        <div>å•è¯æ•°: ${wordCount}</div>
                        <div>åˆ›å»º: ${new Date(book.createdAt).toLocaleDateString()}</div>
                    </div>
                    <div class="deck-actions">
                        <button class="btn-view" onclick="viewBookWords('${book.id}')">æŸ¥çœ‹å•è¯</button>
                        <button class="btn-edit" onclick="editBook('${book.id}')">ç¼–è¾‘</button>
                        <button class="btn-delete" onclick="deleteDeck('${book.id}')">åˆ é™¤</button>
                    </div>
                `;
                bookList.appendChild(card);
            });
            
            // æ¸²æŸ“å•å…ƒå¡ç‰‡
            const unitList = document.getElementById('unitList');
            const units = allDecks.filter(deck => deck.type === 'unit');
            
            unitList.innerHTML = '';
            units.forEach(unit => {
                const wordCount = allVocabularies.filter(word => word.deckId == unit.id).length;
                const parentBook = allDecks.find(d => d.id == unit.parentId);
                
                const card = document.createElement('div');
                card.className = 'deck-card';
                card.innerHTML = `
                    <h4>${unit.name}</h4>
                    <div class="deck-stats">
                        <div>æ‰€å±ä¹¦æœ¬: ${parentBook ? parentBook.name : 'æœªçŸ¥'}</div>
                        <div>å•è¯æ•°: ${wordCount}</div>
                        <div>åˆ›å»º: ${new Date(unit.createdAt).toLocaleDateString()}</div>
                    </div>
                    <div class="deck-actions">
                        <button class="btn-view" onclick="viewUnitWords('${unit.id}')">æŸ¥çœ‹å•è¯</button>
                        <button class="btn-edit" onclick="editDeck('${unit.id}')">ç¼–è¾‘</button>
                        <button class="btn-delete" onclick="deleteDeck('${unit.id}')">åˆ é™¤</button>
                    </div>
                `;
                unitList.appendChild(card);
            });
        }
        
        function deleteDeck(deckId) {
            const deck = allDecks.find(d => d.id == deckId);
            if (!deck) return;
            
            let message = `ç¡®å®šè¦åˆ é™¤"${deck.name}"å—ï¼Ÿ`;
            let isUnit = deck.type === 'unit';
            
            if (isUnit) {
                const wordCount = allVocabularies.filter(word => word.deckId == deckId).length;
                if (wordCount > 0) {
                    message += `\nè¿™å°†åŒæ—¶åˆ é™¤å…¶ä¸­çš„ ${wordCount} ä¸ªå•è¯`;
                }
            } else {
                const relatedUnits = allDecks.filter(d => d.type === 'unit' && d.parentId == deckId);
                const relatedWords = allVocabularies.filter(word => {
                    const unit = allDecks.find(d => d.id == word.deckId);
                    return unit && unit.parentId == deckId;
                });
                
                if (relatedUnits.length > 0) {
                    message += `\nè¿™å°†åŒæ—¶åˆ é™¤å…¶ä¸‹çš„ ${relatedUnits.length} ä¸ªå•å…ƒ`;
                }
                if (relatedWords.length > 0) {
                    message += `\nä»¥åŠ ${relatedWords.length} ä¸ªå•è¯`;
                }
            }
            
            if (!confirm(message + '\næ­¤æ“ä½œä¸å¯æ’¤é”€ï¼')) {
                return;
            }
            
            if (isUnit) {
                allVocabularies = allVocabularies.filter(word => word.deckId != deckId);
            } else {
                // åˆ é™¤ä¹¦æœ¬åŠå…¶å…³è”å†…å®¹
                const unitIds = allDecks
                    .filter(d => d.type === 'unit' && d.parentId == deckId)
                    .map(u => u.id);
                
                allVocabularies = allVocabularies.filter(word => !unitIds.includes(word.deckId));
                allDecks = allDecks.filter(d => !(d.type === 'unit' && d.parentId == deckId));
            }
            
            allDecks = allDecks.filter(d => d.id != deckId);
            saveData();
            initAllSelectors();
            renderDeckCards();
            updateDeckStatistics();
            alert(`"${deck.name}"å·²åˆ é™¤`);
        }
        
        function editBook(bookId) {
            const deck = allDecks.find(d => d.id == bookId);
            if (!deck) return;
            
            currentDeckAction = 'edit';
            currentDeckId = bookId;
            document.getElementById('createDeckTitle').textContent = 'ç¼–è¾‘ä¹¦æœ¬';
            document.getElementById('parentBookGroup').style.display = 'none';
            document.getElementById('newDeckName').value = deck.name;
            document.getElementById('saveDeckButton').textContent = 'ä¿å­˜ä¿®æ”¹';
            document.getElementById('createDeckOverlay').style.display = 'block';
            document.getElementById('createDeckForm').style.display = 'block';
        }
        
        function editDeck(deckId) {
            const deck = allDecks.find(d => d.id == deckId);
            if (!deck) return;
            
            if (deck.type === 'unit') {
                currentDeckAction = 'edit';
                currentDeckId = deckId;
                const parentBookSelect = document.getElementById('parentBookSelect');
                parentBookSelect.innerHTML = '<option value="">è¯·é€‰æ‹©æ‰€å±ä¹¦æœ¬</option>';
                
                const books = allDecks.filter(d => d.type === 'book');
                books.forEach(book => {
                    const option = document.createElement('option');
                    option.value = book.id;
                    option.textContent = book.name;
                    if (book.id == deck.parentId) option.selected = true;
                    parentBookSelect.appendChild(option);
                });
                
                document.getElementById('createDeckTitle').textContent = 'ç¼–è¾‘å•å…ƒ';
                document.getElementById('parentBookGroup').style.display = 'block';
                document.getElementById('newDeckName').value = deck.name;
                document.getElementById('saveDeckButton').textContent = 'ä¿å­˜ä¿®æ”¹';
                document.getElementById('createDeckOverlay').style.display = 'block';
                document.getElementById('createDeckForm').style.display = 'block';
            } else {
                editBook(deckId);
            }
        }
        
        function viewBookWords(bookId) {
            const book = allDecks.find(d => d.id == bookId);
            const units = allDecks.filter(d => d.type === 'unit' && d.parentId == bookId);
            const unitIds = units.map(u => u.id);
            const words = allVocabularies.filter(word => unitIds.includes(word.deckId));
            
            if (words.length === 0) {
                alert(`ä¹¦æœ¬"${book.name}"ä¸­è¿˜æ²¡æœ‰å•è¯`);
                return;
            }
            
            // æ˜¾ç¤ºå•è¯åˆ—è¡¨
            showWordList(words, `ä¹¦æœ¬"${book.name}"çš„å•è¯ (${words.length}ä¸ª)`);
            // åˆ‡æ¢åˆ°ç®¡ç†é¡µé¢
            showPage('manage');
        }
        
        function viewUnitWords(unitId) {
            const unit = allDecks.find(d => d.id == unitId);
            const words = allVocabularies.filter(word => word.deckId == unitId);
            
            if (words.length === 0) {
                alert(`å•å…ƒ"${unit.name}"ä¸­è¿˜æ²¡æœ‰å•è¯`);
                return;
            }
            
            // æ˜¾ç¤ºå•è¯åˆ—è¡¨
            showWordList(words, `å•å…ƒ"${unit.name}"çš„å•è¯ (${words.length}ä¸ª)`);
            // åˆ‡æ¢åˆ°ç®¡ç†é¡µé¢
            showPage('manage');
        }
        
        // ==================== å•è¯ç®¡ç†åŠŸèƒ½ ====================
        function addWord() {
            const chinese = document.getElementById('newChinese').value.trim();
            const japanese = document.getElementById('newJapanese').value.trim();
            const bookId = document.getElementById('addWordBookSelect').value;
            const unitId = document.getElementById('addWordUnitSelect').value;
            
            if (!chinese || !japanese) {
                alert('è¯·è¾“å…¥å®Œæ•´çš„ä¿¡æ¯');
                return;
            }
            
            if (!unitId) {
                alert('è¯·é€‰æ‹©å•è¯è¦æ·»åŠ åˆ°çš„å•å…ƒ');
                return;
            }
            
            const unit = allDecks.find(d => d.id == unitId);
            const book = allDecks.find(d => d.id == unit.parentId);
            
            allVocabularies.push({ 
                id: generateId(),
                chinese, 
                japanese,
                deckId: unitId,
                book: book ? book.name : '',
                unit: unit.name,
                createdAt: new Date().toISOString()
            });
            
            saveData();
            document.getElementById('newChinese').value = '';
            document.getElementById('newJapanese').value = '';
            showWordList();
            updateCounts();
            alert('å•è¯æ·»åŠ æˆåŠŸï¼');
        }
        
        function importFromExcel() {
            const text = document.getElementById('importData').value.trim();
            const bookId = document.getElementById('importBookSelect').value;
            const unitId = document.getElementById('importUnitSelect').value;
            
            if (!text) {
                alert('è¯·ç²˜è´´Excelæ•°æ®');
                return;
            }
            
            if (!unitId) {
                alert('è¯·é€‰æ‹©å•è¯è¦å¯¼å…¥åˆ°çš„å•å…ƒ');
                return;
            }
            
            const unit = allDecks.find(d => d.id == unitId);
            const book = allDecks.find(d => d.id == unit.parentId);
            
            const lines = text.split('\n');
            let imported = 0;
            let skipped = 0;
            
            lines.forEach(line => {
                const parts = line.trim().split(/\s+/);
                if (parts.length >= 2) {
                    const chinese = parts[0].trim();
                    const japanese = parts[1].trim();
                    if (chinese && japanese) {
                        const exists = allVocabularies.some(w => 
                            w.chinese === chinese && w.japanese === japanese);
                        if (!exists) {
                            allVocabularies.push({ 
                                id: generateId(),
                                chinese, 
                                japanese,
                                deckId: unitId,
                                book: book ? book.name : '',
                                unit: unit.name,
                                createdAt: new Date().toISOString()
                            });
                            imported++;
                        } else {
                            skipped++;
                        }
                    }
                }
            });
            
            // è®°å½•ä¸Šä¼ å†å²
            uploadHistory.push({
                type: 'import',
                book: book ? book.name : '',
                unit: unit.name,
                count: imported,
                date: new Date().toISOString()
            });
            
            saveData();
            showWordList();
            updateCounts();
            document.getElementById('importData').value = '';
            alert(`æˆåŠŸå¯¼å…¥ ${imported} ä¸ªå•è¯åˆ°"${unit.name}"${skipped > 0 ? `ï¼Œè·³è¿‡ ${skipped} ä¸ªé‡å¤å•è¯` : ''}`);
        }
        
        function showWordList(filteredWords = null, title = 'æ‰€æœ‰å•è¯') {
            const words = filteredWords || allVocabularies;
            const listDiv = document.getElementById('wordList');
            
            if (words.length === 0) {
                listDiv.innerHTML = `<p>${title} - æš‚æ— å•è¯</p>`;
                return;
            }
            
            let html = `<h4>${title} (${words.length})</h4>`;
            html += '<table style="width:100%; border-collapse:collapse;">';
            html += '<tr style="background:#4a6fa5;color:white;"><th>ä¹¦æœ¬</th><th>å•å…ƒ</th><th>ä¸­æ–‡</th><th>æ—¥è¯­å‡å</th><th>æ“ä½œ</th></tr>';
            
            words.forEach((word, index) => {
                const originalIndex = allVocabularies.findIndex(w => w.id === word.id);
                const wrongItem = wrongWords.find(w => 
                    w.chinese === word.chinese && w.japanese === word.japanese);
                const wrongCount = wrongItem ? wrongItem.wrongCount : 0;
                
                html += `
                    <tr style="border-bottom:1px solid #ddd;">
                        <td style="padding:10px;">${word.book || 'æœªåˆ†ç±»'}</td>
                        <td style="padding:10px;">${word.unit || 'æœªåˆ†ç±»'}</td>
                        <td style="padding:10px;">${word.chinese}</td>
                        <td style="padding:10px;">${word.japanese}</td>
                        <td style="padding:10px;">
                            ${wrongCount > 0 ? `<span class="wrong-count" title="é”™è¯¯${wrongCount}æ¬¡">${wrongCount}</span>` : ''}
                            <button onclick="editWord(${originalIndex})" style="padding:5px 10px;background:#ff9800;color:white;margin-right:5px;">ç¼–è¾‘</button>
                            <button onclick="deleteWord(${originalIndex})" style="padding:5px 10px;background:red;color:white;">åˆ é™¤</button>
                        </td>
                    </tr>
                `;
            });
            
            html += '</table>';
            listDiv.innerHTML = html;
        }
        
        function editWord(index) {
            const word = allVocabularies[index];
            document.getElementById('editChinese').value = word.chinese;
            document.getElementById('editJapanese').value = word.japanese;
            
            // å¡«å……ç¼–è¾‘è¡¨å•çš„é€‰æ‹©å™¨
            fillEditSelectors();
            
            // è®¾ç½®å½“å‰å€¼
            const unit = allDecks.find(d => d.name === word.unit && d.type === 'unit');
            if (unit) {
                const book = allDecks.find(d => d.id == unit.parentId);
                if (book) {
                    document.getElementById('editBookSelect').value = book.id;
                    fillUnitSelectorsByBook(book.id, document.getElementById('editUnitSelect'));
                    document.getElementById('editUnitSelect').value = unit.id;
                }
            }
            
            // å­˜å‚¨æ­£åœ¨ç¼–è¾‘çš„å•è¯ç´¢å¼•
            window.editingWordIndex = index;
            
            // æ˜¾ç¤ºç¼–è¾‘è¡¨å•
            document.getElementById('editOverlay').style.display = 'block';
            document.getElementById('editForm').style.display = 'block';
        }
        
        function saveEditedWord() {
            const index = window.editingWordIndex;
            if (index === undefined) return;
            
            const chinese = document.getElementById('editChinese').value.trim();
            const japanese = document.getElementById('editJapanese').value.trim();
            const unitId = document.getElementById('editUnitSelect').value;
            
            if (!chinese || !japanese) {
                alert('è¯·è¾“å…¥å®Œæ•´çš„ä¿¡æ¯');
                return;
            }
            
            if (!unitId) {
                alert('è¯·é€‰æ‹©å•è¯æ‰€å±çš„å•å…ƒ');
                return;
            }
            
            const unit = allDecks.find(d => d.id == unitId);
            const book = allDecks.find(d => d.id == unit.parentId);
            
            allVocabularies[index] = {
                ...allVocabularies[index],
                chinese,
                japanese,
                deckId: unitId,
                book: book ? book.name : '',
                unit: unit.name
            };
            
            saveData();
            showWordList();
            closeEditForm();
            alert('å•è¯ä¿®æ”¹æˆåŠŸï¼');
        }
        
        function closeEditForm() {
            document.getElementById('editOverlay').style.display = 'none';
            document.getElementById('editForm').style.display = 'none';
            window.editingWordIndex = undefined;
        }
        
        function deleteWord(index) {
            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªå•è¯å—ï¼Ÿ')) {
                const word = allVocabularies[index];
                const wrongIndex = wrongWords.findIndex(w => 
                    w.chinese === word.chinese && w.japanese === word.japanese);
                if (wrongIndex >= 0) {
                    wrongWords.splice(wrongIndex, 1);
                }
                allVocabularies.splice(index, 1);
                saveData();
                showWordList();
                updateCounts();
            }
        }
        
        // ==================== ä¸Šä¼ è®°å½•åŠŸèƒ½ ====================
        function renderUploadHistory() {
            const historyDiv = document.getElementById('uploadHistory');
            if (uploadHistory.length === 0) {
                historyDiv.innerHTML = '<p>æš‚æ— ä¸Šä¼ è®°å½•</p>';
                return;
            }
            
            let html = '';
            uploadHistory.forEach((record, index) => {
                const date = new Date(record.date).toLocaleString();
                html += `
                    <div class="upload-item">
                        <div>
                            <strong>${record.type === 'import' ? 'å¯¼å…¥' : 'è¿ç§»'}</strong>
                            ${record.book ? `åˆ° ${record.book}` : ''}
                            ${record.unit ? ` - ${record.unit}` : ''}
                            <br>
                            <small>${date} | ${record.count}ä¸ªå•è¯</small>
                        </div>
                        <button onclick="deleteUploadRecord(${index})" style="padding:5px 10px;background:red;color:white;font-size:12px;">åˆ é™¤</button>
                    </div>
                `;
            });
            
            historyDiv.innerHTML = html;
        }
        
        function deleteUploadRecord(index) {
            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡ä¸Šä¼ è®°å½•å—ï¼Ÿ')) {
                uploadHistory.splice(index, 1);
                saveData();
                renderUploadHistory();
            }
        }
        
        // ==================== ç»Ÿè®¡å’Œæ›´æ–°åŠŸèƒ½ ====================
        function updateCounts() {
            document.getElementById('wordCount').textContent = allVocabularies.length;
            document.getElementById('totalWordCount').textContent = allVocabularies.length;
            document.getElementById('deckCount').textContent = allDecks.filter(d => d.type === 'book').length;
        }
        
        function updateDeckStatistics() {
            const statsDiv = document.getElementById('deckStatistics');
            const books = allDecks.filter(d => d.type === 'book');
            const units = allDecks.filter(d => d.type === 'unit');
            
            let html = `
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                    <div style="background: #e3f2fd; padding: 10px; border-radius: 5px;">
                        <div style="font-size: 20px; font-weight: bold;">${books.length}</div>
                        <div>ä¹¦æœ¬æ•°é‡</div>
                    </div>
                    <div style="background: #e8f5e8; padding: 10px; border-radius: 5px;">
                        <div style="font-size: 20px; font-weight: bold;">${units.length}</div>
                        <div>å•å…ƒæ•°é‡</div>
                    </div>
                    <div style="background: #fff3cd; padding: 10px; border-radius: 5px;">
                        <div style="font-size: 20px; font-weight: bold;">${allVocabularies.length}</div>
                        <div>å•è¯æ€»æ•°</div>
                    </div>
                    <div style="background: #ffebee; padding: 10px; border-radius: 5px;">
                        <div style="font-size: 20px; font-weight: bold;">${wrongWords.length}</div>
                        <div>é”™é¢˜æ•°é‡</div>
                    </div>
                </div>
            `;
            
            // æ·»åŠ ä¹¦æœ¬è¯¦æƒ…
            if (books.length > 0) {
                html += '<h4 style="margin-top: 20px;">ä¹¦æœ¬è¯¦æƒ…ï¼š</h4>';
                books.forEach(book => {
                    const relatedUnits = allDecks.filter(d => d.type === 'unit' && d.parentId == book.id);
                    const wordCount = allVocabularies.filter(word => {
                        const unit = allDecks.find(d => d.id == word.deckId);
                        return unit && unit.parentId == book.id;
                    }).length;
                    
                    html += `
                        <div style="margin: 5px 0; padding: 5px; background: #f5f5f5; border-radius: 3px;">
                            <strong>${book.name}</strong>: ${relatedUnits.length}ä¸ªå•å…ƒ, ${wordCount}ä¸ªå•è¯
                        </div>
                    `;
                });
            }
            
            statsDiv.innerHTML = html;
        }
        
        function updateProgressDisplay() {
            if (practiceWords.length === 0) {
                document.getElementById('currentProgress').textContent = '0';
                document.getElementById('totalPractice').textContent = '0';
                document.getElementById('progressFill').style.width = '0%';
                return;
            }
            const progress = currentIndex + 1;
            const total = practiceWords.length;
            const percent = Math.round((progress / total) * 100);
            document.getElementById('currentProgress').textContent = progress;
            document.getElementById('totalPractice').textContent = total;
            document.getElementById('progressFill').style.width = percent + '%';
        }
        
        function updatePracticeStats() {
            const total = practiceStats.total;
            if (total === 0) {
                document.getElementById('correctRate').textContent = '0%';
                return;
            }
            const answered = practiceStats.correct + practiceStats.wrong;
            const correctRate = Math.round((practiceStats.correct / answered) * 100) || 0;
            document.getElementById('correctRate').textContent = correctRate + '%';
        }
        
        // ==================== é”™é¢˜åŠŸèƒ½ ====================
        function showWrongList() {
            const listDiv = document.getElementById('wrongList');
            if (wrongWords.length === 0) {
                listDiv.innerHTML = '<p>æš‚æ— é”™é¢˜</p>';
                return;
            }
            
            wrongWords.sort((a, b) => b.wrongCount - a.wrongCount);
            let html = '<table style="width:100%; border-collapse:collapse;">';
            html += '<tr style="background:#ff9800;color:white;"><th>é”™è¯¯æ¬¡æ•°</th><th>ä¸­æ–‡</th><th>æ—¥è¯­å‡å</th><th>æ“ä½œ</th></tr>';
            
            wrongWords.forEach((wrongItem, index) => {
                const lastWrong = new Date(wrongItem.lastWrong).toLocaleDateString();
                html += `
                    <tr style="border-bottom:1px solid #ddd;">
                        <td style="padding:10px; text-align:center;">
                            <span class="wrong-count">${wrongItem.wrongCount}</span>
                            <div style="font-size:12px; color:#666;">ä¸Šæ¬¡:${lastWrong}</div>
                        </td>
                        <td style="padding:10px;">${wrongItem.chinese}</td>
                        <td style="padding:10px;">${wrongItem.japanese}</td>
                        <td style="padding:10px;">
                            <button onclick="removeWrong(${index})" style="padding:5px 10px;">åˆ é™¤</button>
                        </td>
                    </tr>
                `;
            });
            
            html += '</table>';
            listDiv.innerHTML = html;
        }
        
        function removeWrong(index) {
            if (confirm('ç¡®å®šè¦ä»é”™é¢˜é›†åˆ é™¤å—ï¼Ÿ')) {
                wrongWords.splice(index, 1);
                saveData();
                showWrongList();
            }
        }
        
        function clearWrong() {
            if (confirm('ç¡®å®šè¦æ¸…ç©ºé”™é¢˜é›†å—ï¼Ÿ')) {
                wrongWords = [];
                saveData();
                showWrongList();
            }
        }
        
        function practiceWrong() {
            document.getElementById('practiceMode').value = 'wrong';
            onPracticeModeChange();
            showPage('practice');
        }
        
        // ==================== å…¶ä»–åŠŸèƒ½ ====================
        function handleSubmit(event) {
            event.preventDefault();
            handleFormSubmit();
            return false;
        }
        
        function handleFormSubmit() {
            if (!isAnswerChecked) {
                checkAnswer();
            } else {
                nextWord();
            }
        }
        
        function handleInputBlur() {
            if (isMobile && !isAnswerChecked && document.getElementById('answer').value.trim()) {
                setTimeout(() => {
                    if (!isAnswerChecked) {
                        checkAnswer();
                    }
                }, 200);
            }
        }
        
        function loadSettings() {
            if (localStorage.getItem('japaneseSettings')) {
                settings = JSON.parse(localStorage.getItem('japaneseSettings'));
                document.getElementById('practiceCount').value = settings.practiceCount || 30;
            }
        }
        
        function saveSettings() {
            settings.practiceCount = parseInt(document.getElementById('practiceCount').value);
            localStorage.setItem('japaneseSettings', JSON.stringify(settings));
        }
        
        function exportData() {
            const data = {
                allDecks: allDecks,
                allVocabularies: allVocabularies,
                wrongWords: wrongWords,
                uploadHistory: uploadHistory,
                settings: settings,
                exportDate: new Date().toISOString()
            };
            
            const dataStr = JSON.stringify(data, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `æ—¥è¯­å•è¯å¤‡ä»½_${new Date().toISOString().slice(0,10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
            alert('æ•°æ®å·²å¯¼å‡ºä¸ºJSONæ–‡ä»¶ï¼Œè¯·å°†æ­¤æ–‡ä»¶å‘é€åˆ°æ‰‹æœº');
        }
        
        function importData() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            if (!file) {
                alert('è¯·é€‰æ‹©æ–‡ä»¶');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    allDecks = data.allDecks || [];
                    allVocabularies = data.allVocabularies || [];
                    wrongWords = data.wrongWords || [];
                    uploadHistory = data.uploadHistory || [];
                    settings = data.settings || { practiceCount: 30 };
                    
                    saveData();
                    loadSettings();
                    initAllSelectors();
                    showWordList();
                    showWrongList();
                    renderDeckCards();
                    updateDeckStatistics();
                    renderUploadHistory();
                    
                    alert(`æˆåŠŸå¯¼å…¥æ•°æ®ï¼š
        - ${allDecks.length} ä¸ªè¯åº“
        - ${allVocabularies.length} ä¸ªå•è¯
        - ${wrongWords.length} ä¸ªé”™é¢˜`);
                } catch(error) {
                    alert('æ–‡ä»¶æ ¼å¼é”™è¯¯ï¼Œè¯·é€‰æ‹©æ­£ç¡®çš„å¤‡ä»½æ–‡ä»¶');
                }
            };
            reader.readAsText(file);
        }
        
        function clearAllData() {
            if (confirm('âš ï¸ è­¦å‘Šï¼šè¿™å°†åˆ é™¤æ‰€æœ‰æ•°æ®ï¼\n\nç¡®å®šè¦ç»§ç»­å—ï¼Ÿ')) {
                if (confirm('æœ€åç¡®è®¤ï¼šçœŸçš„è¦åˆ é™¤æ‰€æœ‰å•è¯å’Œè®°å½•å—ï¼Ÿ')) {
                    allVocabularies = [];
                    allDecks = [];
                    wrongWords = [];
                    uploadHistory = [];
                    practiceStats = { total: 0, correct: 0, wrong: 0 };
                    practiceWords = [];
                    currentIndex = 0;
                    githubConfig = { username: '', token: '', gistId: '' };
                    
                    saveData();
                    localStorage.removeItem('githubConfig');
                    showWordList();
                    showWrongList();
                    renderDeckCards();
                    updateDeckStatistics();
                    renderUploadHistory();
                    updateSyncStatus();
                    
                    alert('æ‰€æœ‰æ•°æ®å·²æ¸…ç©º');
                }
            }
        }
    </script>
</body>
</html>